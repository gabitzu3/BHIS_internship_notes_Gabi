# Browser Malware

# 1. Overview

**Browser malware** is any malicious code or configuration that abuses a web browser or its ecosystem (extensions, plugins, saved credentials, profiles, web applications, or browser-executed script) to achieve attacker objectives such as credential theft, persistence, command execution, data exfiltration, or initial access. Examples include malicious browser extensions, drive-by downloads, JavaScript-based loaders, web injects, and malvertising.

Why browsers are attractive targets:

- Browsers have extensive privileges to access stored credentials, cookies, and active sessions.
- Vast plugin/extension ecosystems create a large attack surface.
- Browsers execute JavaScript and parse complex content (HTML/CSS/JS) which can be obfuscated or weaponized.
- Users often re-use sessions and credentials; session hijacking is low-effort and high-value.

Key takeaways:

- Browser threats are often stealthy and blend with normal web traffic.
- Detection requires correlating multiple telemetry sources (endpoint + network + browser artifacts + proxy logs).
- Rapid collection of volatile artifacts (memory, browser process, network capture) is critical.

# 2. Threat models & attacker motivations

Common attacker goals achieved via browser malware:

- **Credential theft** (saved passwords, session cookies, OAuth tokens)
- **Session hijacking** (stealing cookies or web storage)
- **Persistent access** (malicious extensions or browser profiles)
- **Command & Control (C2)** via web protocols (HTTP/S) or WebSockets
- **Data exfiltration** via web uploads to attacker-controlled endpoints
- **Initial access** (malicious links, malvertising, compromised websites)



Attack vectors:

- Phishing / malicious links (drive-by) → exploit chain
- Malicious or trojanized extensions or extension updates
- Compromised websites serving obfuscated JavaScript
- Third-party content (ads, CDNs) -> malvertising
- Supply-chain (infected libraries, npm/JS packages, extension marketplaces)

# 3. Browser-malware categories & patterns

### 3.1 Malicious Browser Extensions

- Installed directly by user trickery or silently through installers.
- May request broad permissions to access all websites and modify requests/responses.
- Can inject JS into pages to steal credentials, modify content, or add persistent backdoors.
- Detection cues: unknown extension IDs, frequent extension updates, unusual permissions.

### 3.2 Drive-by Downloads & Exploit Kits

- Compromised sites or ads redirect to exploit chains; rely on browser/plug-in vulnerabilities.
- Modern browsers reduce this surface, but zero-days and unpatched plug-ins still exploited.

### 3.3 Malvertising & Redirect Chains

- Ads load third-party scripts that perform redirects or load obfuscated payloads.
- Evidence: many short-lived redirect domains, many HTTP 302s, ad networks as common referrers.

### 3.4 Web-based Loaders & Fileless JavaScript

- Attackers run payloads purely in JS (eval, Function constructor, wasm, WebAssembly) or decode base64 and execute in memory.
- Often used to retrieve and execute second-stage payloads or perform browser-based reconnaissance.


### 3.5 Credential Harvesters & Session Hijackers

- Keyloggers via injected JS, form-grabbing, or exfiltration of cookies/localStorage/IndexedDB.


# 4. Attack lifecycle / kill chain mapped to browser threats

1. **Reconnaissance**: malicious JS probes page DOM, cookies, localStorage
2. **Initial Access**: phishing, malvertising, compromised extension install
3. **Execution**: JS eval, extension background script executes, WebSocket open
4. **Persistence**: malicious extension, manipulated startup settings, scheduled tasks created via browser-based installers
5. **Privilege Escalation**: using system components via child processes spawned from browser
6. **C2 / Command & Control**: beaconing over HTTPS, WebSockets, long-polling
7. **Exfiltration**: POSTs to attacker endpoints, data encoded in User-Agent or query strings
8. **Cleanup / Evasion**: code obfuscation, frequent domain rotation, fast-flux

# 5. Telemetry sources (what to collect & why)

**Endpoint / Host**

- Process creation logs (parent/child relationships). A browser spawning `cmd.exe`, `powershell`, `rundll32`, or `regsvr32` is suspicious.
- EDR process and module load telemetry (browser subsystems, unexpected DLLs injected into browser processes).
- File system events (new/modified extension directories, profile changes).
- Registry changes (policies or extension-related keys on Windows).
- Windows Scheduled Tasks / Services.

**Browser-specific telemetry**

- Extensions list and permissions requested.
- Browser history and recent URLs.
- Cookies, Local Storage, Session Storage, IndexedDB.
- Downloads (file names, destinations, hashes).
- Network requests made by browser (HTTP requests, WebSocket activity).
- Content Security Policy (CSP) violations.

**Network**

- Proxy and web gateway logs (URL, referrer, user, bytes transferred).
- DNS logs (rapidly changing domains, domain generation algorithm (DGA)-like patterns).
- TLS metadata (SNI, certificate anomalies, certificate chains, ephemeral certs).
- HTTP request characteristics (User-Agent anomalies, long query strings, base64 payloads in POSTs).

**Memory**

- Browser process memory (JS strings, in-memory DOM, heap dumps) — often holds decoded payloads and keys.
- System memory for child processes spawned by browser.

**Email & CASB**

- Malicious email links leading to drive-by or phishing pages.

**Log correlation**

- Combine user identity, web logs, endpoint process chain, and network indicators to build confidence.

# 6. IoCs and behavioral indicators

**Static IoCs** (useful but easily changed):

- Malicious domains and IPs
- File hashes (downloaded payloads, extension CRX files)
- Extension IDs and publishers
- URLs with suspicious patterns (long base64 strings, unusual query parameters)

**Behavioral IoCs** (higher value):

- Browser process spawning command shells or unexpected child processes.
- Abnormal outbound HTTPS POSTs with small payloads at regular intervals (beaconing).
- Repeated requests to short-lived domains with short TTLs.
- Requests where the path contains `eval(`, `Function(`, `fromCharCode`, `atob(`, or long encoded strings.
- Presence of `chrome-extension://<id>/` requests on systems that should not have that extension.
- Extensions requesting broad host permissions (ex: `<all_urls>`).

**Examples of suspicious artifacts**:

- Unknown extension installed with `background` scripts that perform XHR/fetch.
- Cookies or localStorage entries with names like `_auth_token`, `sessionid` sent to unusual third-party hosts.

# 7. Detection techniques & sample signatures/queries
>[!TIP]
>
> Below are practical, ready-to-adapt detection queries and signature examples for common platforms.

---

## 7.1 Splunk

**Detect outbound POSTs with long base64 payloads (proxy logs)**

```
index=proxy sourcetype=proxy_access method=POST
| eval body_len=len(body)
| where body_len>1000 OR match(body,"[A-Za-z0-9+/]{100,}")
| table _time, src_ip, user, uri, host, body_len
```


## 7.2 Elasticsearch / Kibana (ELK) queries

**Detects POST requests with suspicious JavaScript payloads in the body (ex: use of eval()).* *

```
GET /_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "http.request.method": "POST" }},
        { "regexp": { "http.request.body": ".*eval\\(.*" }}
      ]
    }
  }
}

```

## 7.3 Sigma rule

```
title: Browser spawning suspicious child process
id: d3c36b1d-5b2f-4f99-9999-aaaaaaaaaaaa
status: experimental
logsource:
  product: windows
  service: sysmon
detection:
  selection_image:
    Image|endswith: '\chrome.exe'
  selection_cmd:
    CommandLine|contains: 'powershell'
  condition: selection_image and selection_cmd
falsepositives:
  - Legitimate admin scripts using browser-based automation
level: high
```

## 7.4 Suricata/IDS rule examples (network)

**Detect HTTP responses that contain typical JS obfuscation markers (eval, fromCharCode)**

```
alert http any any -> any any (msg:"JS Obfuscation in HTTP response - eval/fromCharCode"; \
content:"eval("; nocase; http_response_body; \
pcre:"/fromCharCode\s*\(/i"; sid:1000001; rev:1;)
```

**Detect large base64 POST payloads**

```
alert http any any -> any any (msg:"Large base64 POST likely exfiltration"; \
http_method; content:"POST"; \
pcre:"/[A-Za-z0-9+/]{300,}={0,2}/"; \
detection_filter: track by_dst, count 5, seconds 60; sid:1000002; rev:1;)
```

## 7.5 Zeek (Bro) scripts

**Detect long obfuscated JS strings in HTTP responses and generate notices **

```
event http_response(c: connection, is_orig: bool, status_code: count, 
                    reason: string, headers: http_headers, body: string)
{
    if ( is_orig ) {
        # Check if content-type contains "javascript"
        local ct = headers["content-type"];
        if ( ct != null && /javascript/ in ct ) {
            # Look for suspiciously long strings with typical JS obfuscation markers
            if ( |body| > 1000 && /eval\(.*\)/ in body ) {
                NOTICE([$note=Notice::Info,
                        $msg=fmt("Long obfuscated JS detected from %s", c$id$resp_h),
                        $conn=c]);
            }
        }
    }
}
```

**Detect unusual Content-Type headers (ex: application/octet-stream from webpages) and long POST bodies**

```
event http_response(c: connection, is_orig: bool, status_code: count,
                    reason: string, headers: http_headers, body: string)
{
    if ( is_orig ) {
        local ct = headers["content-type"];
        if ( ct != null && ct == "application/octet-stream" ) {
            NOTICE([$note=Notice::Info,
                    $msg=fmt("Unusual Content-Type (application/octet-stream) from %s", c$id$resp_h),
                    $conn=c]);
        }
    }
}

event http_request(c: connection, is_orig: bool, method: string,
                   uri: string, version: string, headers: http_headers, body: string)
{
    if ( is_orig && method == "POST" ) {
        if ( |body| > 1000 ) {
            NOTICE([$note=Notice::Info,
                    $msg=fmt("Large POST body detected from %s", c$id$orig_h),
                    $conn=c]);
        }
    }
}
```

## 7.6 YARA for JavaScript files

```yara
rule Suspicious_Obfuscated_JS
{
  meta:
    author = "SOC Team"
    description = "Detect common obfuscation patterns in JS files"
  strings:
    $eval = "eval(" fullword
    $fromChar = "fromCharCode(" fullword
    $atob = "atob(" fullword
    $long_hex = /0x[0-9a-fA-F]{8,}/
  condition:
    (1 of ($eval, $fromChar, $atob)) or $long_hex
}
```

*Note: YARA is best on saved JS files or cached responses captured by a proxy.*

# 8. Threat hunting

**A — Hunt for malicious extensions**

1. Pull list of installed extensions for all endpoints.
   - Windows Chrome: `%LOCALAPPDATA%\Google\Chrome\User Data\Default\Extensions` (each subfolder is an ID)
   - Collect extension manifest (`manifest.json`) and `background.js`.
2. Flag extensions with permissions like `*://*/*` or `tabs` and not in the known software inventory.
3. Cross-reference extension IDs with marketplace and vendor metadata.
4. If suspicious, search for network calls from browser to `chrome-extension://<id>` or background URLs.

**B — Hunt for drive-by or malvertising chains**

- Look for sequences of HTTP 302/301 responses originating from ad networks, followed by requests to short-lived domains, followed by downloads.
- Query web/proxy logs for high redirect count within single sessions.

**C — Hunt for JS-based beaconing**

- Look for regular outbound HTTPS POST/GET patterns with small payloads from browser users.
- Correlate with domain age and registration anomalies.

*D — Hunt for credential theft / session exfiltration**

- Search for outgoing requests where request body contains cookie names or session parameter patterns.
- Monitor for `Set-Cookie` being sent to third-party domains.

# 9. Browser forensics — artifact locations & extraction

>[!IMPORTANT]
>
> Collect both *static* artifacts (files on disk) and *volatile* artifacts (memory, running processes).

## 9.1 Chrome / Chromium & Edge (Windows)

- User data folder: `%LOCALAPPDATA%\Google\Chrome\User Data\Default\`
  - `History` — SQLite DB of browsing history (WebKit timestamps).
  - `Cookies` — SQLite DB (encrypted). On Windows cookies are DPAPI-protected.
  - `Login Data` — SQLite DB with saved credentials (encrypted via DPAPI).
  - `Local Storage` — leveldb files under `Local Storage\leveldb`
  - `IndexedDB` — folder with DBs.
  - `Extensions` — folder with extension IDs.
  - `Cache` — HTTP cache files.

**Commands:**

- Read `History` with sqlite3: `sqlite3 History "SELECT url, title, last_visit_time FROM urls ORDER BY last_visit_time DESC LIMIT 100;"`
- Note: Chrome `last_visit_time` is WebKit time: microseconds since 1601-01-01. Convert in analysis.

## 9.2 Firefox (Windows/macOS/Linux)

- Profiles are located under `%APPDATA%\Mozilla\Firefox\Profiles\` (Windows) or `~/Library/Application Support/Firefox/Profiles/` (macOS).
  - `places.sqlite` — history and bookmarks
  - `cookies.sqlite` — cookies
  - `logins.json` + `key4.db` — saved logins (use Mozilla decryption procedure)
  - `extensions/` and `extensions.json`


## 9.3 Linux paths

- Chrome: `~/.config/google-chrome/Default/`
- Firefox: `~/.mozilla/firefox/`

## 9.4 Extracting extension details

- Locate extension ID folder; open `manifest.json` to examine permissions and background scripts.
- Hash the extension CRX or extracted files; search enterprise telemetry for the ID.

## 9.5 Decrypting stored credentials (defensive/forensic)

- Windows Chrome/Edge: saved credentials are protected via DPAPI. Use forensic tooling (ex: built-in EDR, mimikatz DPAPI extraction for incident response with legal/approved scope) to decrypt if authorized.
- Firefox: `logins.json` + `key4.db` require the profile's key material

# 10. Memory & timeline forensics

**Why memory matters**

- JavaScript payloads, in-memory decoded strings, and WebSocket communication are often only visible in memory.
- Ephemeral data such as session tokens or ephemeral keys are frequently recovered only from process memory.

**Memory collection guidance**

- Acquire full memory of the host (or targeted browser processes) using forensic tool appropriate for platform (FTK Imager, Magnet, DumpIt, `winpmem`, `mac memory tools`, `LiME` on Linux).
- If possible, snapshot the specific browser process using EDR process dumping functions.

**Useful memory analysis goals**

- Search for plain-text tokens, cookie values, and decoded JS strings (ex: `eval(atob('...'))` decoded content).
- Identify loaded modules/handles and suspicious injected DLLs.
- Network sockets open by browser processes (host\:port) and any established WebSocket connections.

**Timeline building**

- Convert browser timestamps (Chrome WebKit epoch) to human-readable time. Example formula (conceptual):
  - Chrome time (microseconds since 1601-01-01) → convert to Unix epoch.
- Correlate browser history entries, proxy logs, process creation events, and network flows to create an event timeline.

# 11. Incident response (triage → recover)

**Initial triage**

1. Identify and isolate affected hosts (network quarantine or VLAN quarantine via NAC or firewall rules).
2. Record scope — user(s), host(s), time window.
3. Triage host without powering off (collect volatile evidence first): process list, network connections, browser processes, loaded extensions.

**Evidence collection**

- Collect memory image and targeted process dumps.
- Collect browser profile directory (copy whole `User Data` / profile directory), including `Extensions`, `Login Data`, `Cookies`, `Local Storage`.
- Export browser process command-line and parent-child relationships from EDR.
- Save network captures (pcap) of ongoing suspicious activity.

**Containment**

- Remove suspicious extensions (but ensure you capture a forensic copy for analysis).
- Block malicious domains/IPs at DNS and firewall level.
- Disable common persistence mechanisms if found (scheduled tasks, startup entries).

**Root cause & eradication**

- Determine initial vector (phishing link, compromised site, extension update).
- Remove artifacts, rotate credentials (particularly if credentials or session tokens exposed). Prefer forcing password resets and revoking sessions for high-value services.
- Reimage if the host is deeply compromised — rebuild from known-good image.

**Recovery**

- Restore user to network with monitoring in place.
- Implement additional monitoring for IOCs across environment.


# 12. Mitigation, hardening & prevention controls

**Policy & configuration**

- Enforce extension whitelisting and centrally manage extension installs via Group Policy or enterprise policies (Chrome/Edge/Firefox enterprise)
- Disable auto-updates for extension stores where supply-chain risk is high; or better, control updates centrally.
- Disable saving passwords in managed browsers; or store centrally with SSO and enterprise password managers.
- Enforce strict CSPs on internally-managed web applications.

**Network & gateway controls**

- Use secure web gateway (SWG) to inspect HTTP(S) traffic for obfuscation and block known-malicious domains.
- DNS filtering for known malicious domains and suspicious newly‑registered domains.
- Consider remote browser isolation for high-risk users (financial ops, executives).

**EDR & detection**

- Monitor for browser spawning unexpected children.
- Alert on extension installs on non-admin managed hosts.
- Monitor for unusual WebSocket and long-polling traffic patterns.


**Operational**

- Regularly review extension inventory and remove rarely used or high-permission extensions.
- Maintain up-to-date browser versions and patch management.

# 13. Integration with EDR, proxy, NGFW, CASB, and MDM

- **EDR**: ingest process creations, module loads, in-memory indicators, and allow process dumping and live response actions (remove extension, kill process, quarantine file).
- **Proxy/SWG**: capture full HTTP bodies when possible (or use metadata when body capture not allowed) to detect obfuscated JS and base64 payloads.
- **NGFW**: block known-bad IPs/domains and limit outbound unusual ports.
- **CASB**: detect unusual cloud app usage originating from browser sessions, token misuse, or data exfiltration to sanctioned/unsanctioned apps.
- **MDM**: enforce browser policies on endpoints (extension whitelisting, password settings).

# 14. IOC sharing



Provide IOCs in standard formats (CSV, STIX/TAXII if supported) to threat intel consumers and upstream blocks (DNS sinkhole, firewall rules).



# 15. Tools & references 

**For analysis & collection**

- EDR vendor tools (CrowdStrike, SentinelOne, Carbon Black, etc.)
- `sqlite3` for Chrome/Firefox DB analysis
- `strings`, `yara`, `ripgrep` for static JS scanning
- `Volatility` / `Volatility 3` for memory analysis
- `winpmem`, `LiME` for memory acquisition
- Browser-specific utilities such as BrowserHistoryView (NirSoft) or custom scripts to parse LevelDB / IndexedDB
- `tcpdump` / `Wireshark` for network capture

**Suggested scripts / snippets**

- **Convert Chrome WebKit timestamp to UNIX** (example Python snippet):

```python
# Chrome WebKit time (microseconds since 1601-01-01)
import datetime
def chrome_time_to_unix(microseconds):
    epoch_start = datetime.datetime(1601,1,1)
    return epoch_start + datetime.timedelta(microseconds=microseconds)

# usage: chrome_time_to_unix(13217452800000000)
```

- **Extract Chrome history entries (sqlite3)**

```
sqlite3 "History" "SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch'), url, title FROM urls ORDER BY last_visit_time DESC LIMIT 50;"
```

*(Explanation: 11644473600 converts WebKit epoch to Unix epoch for seconds; **`last_visit_time`** stored in microseconds — adjust division accordingly.)*

**Quick reference: browser artifact file names**

- Chrome: `History`, `Cookies`, `Login Data`, `Bookmarks`, `Preferences`, `Extensions` folder
- Firefox: `places.sqlite`, `cookies.sqlite`, `logins.json`, `key4.db`, `extensions.json`


---

## Quick detection checklist for triage

1. Check process tree for browser child processes that are suspicious.
2. Dump running browser processes and search memory for `eval(`, `fromCharCode`, `atob(`, `WebSocket`.
3. Export the extension list and manifest files for all endpoints of the user.
4. Query web/proxy logs for POST requests containing long encoded payloads or many redirects.
5. Search for recently modified extension folders or sudden new profiles.
6. Revoke sessions and force password resets for affected accounts.


---

*Check out the [browser malware lab here](./browser_malware_lab.md)!*